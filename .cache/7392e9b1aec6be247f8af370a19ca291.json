{"dependencies":[],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n\n  constructor(attrs) {\n    const { data, value, type, path, errors = [] } = attrs;\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${value}\\`.`;\n    super(message);\n    this.data = data;\n    this.path = path;\n    this.value = value;\n    this.type = type;\n    this.errors = errors;\n    if (!errors.length) errors.push(this);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n    case 'Promise':\n      return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap':\n      return 'weakmap';\n    case 'WeakSet':\n      return 'weakset';\n    case 'Map':\n      return 'map';\n    case 'Set':\n      return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array':\n      return 'int8array';\n    case 'Uint8Array':\n      return 'uint8array';\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array':\n      return 'int16array';\n    case 'Uint16Array':\n      return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array':\n      return 'int32array';\n    case 'Uint32Array':\n      return 'uint32array';\n    case 'Float32Array':\n      return 'float32array';\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n    case '[object Map Iterator]':\n      return 'mapiterator';\n    case '[object Set Iterator]':\n      return 'setiterator';\n    case '[object String Iterator]':\n      return 'stringiterator';\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@';\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@';\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n\n  constructor(name, type, validate) {\n    this.name = name;\n    this.type = type;\n    this.validate = validate;\n  }\n\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) return schema[KIND];\n  if (schema instanceof Kind) return schema;\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults, options) : list(schema, defaults, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults, options);\n      }\n\n    case 'string':\n      {\n        let required = true;\n        let type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          const scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults, options);\n        } else if (schema.includes('&')) {\n          const scalars = schema.split(/\\s*&\\s*/g);\n          type = intersection(scalars, defaults, options);\n        } else {\n          type = scalar(schema, defaults, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (\"development\" !== 'production') {\n    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);\n  } else {\n    throw new Error(`Invalid schema: ${schema}`);\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (\"development\" !== 'production') {\n      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const keys = any(schema[0], undefined, options);\n  const values = any(schema[1], undefined, options);\n  const name = 'dict';\n  const type = `dict<${keys.type},${values.type}>`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = {};\n    const errors = [];\n\n    for (let k in value) {\n      const v = value[k];\n      const [e, r] = keys.validate(k);\n\n      if (e) {\n        e.path = [k].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        continue;\n      }\n\n      k = r;\n      const [e2, r2] = values.validate(v);\n\n      if (e2) {\n        e2.path = [k].concat(e2.path);\n        e2.data = value;\n        errors.push(e2);\n        continue;\n      }\n\n      ret[k] = r2;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'enum';\n  const type = schema.map(s => {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options);\n  const l = list([e], defaults, options);\n  return l;\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'function';\n  const type = '<function>';\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema(value) ? [undefined, value] : [{ type, value, data: value, path: [] }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance';\n  const type = `instance<${schema.name}>`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'interface';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = [];\n\n    for (const key in properties) {\n      const v = value[key];\n      const kind = properties[key];\n      const [e] = kind.validate(v);\n\n      if (e) {\n        e.path = [key].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        continue;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, value];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  let kind;\n  let struct;\n  const name = 'lazy';\n  const type = `lazy...`;\n  const compile = value => {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (\"development\" !== 'production') {\n      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const array = scalar('array', undefined, options);\n  const element = any(schema[0], undefined, options);\n  const name = 'list';\n  const type = `[${element.type}]`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    const errors = [];\n    const ret = [];\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      const [e, r] = element.validate(v);\n\n      if (e) {\n        e.path = [i].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal';\n  const type = `literal: ${JSON.stringify(schema)}`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'object';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n    const valueKeys = Object.keys(value);\n    const propertiesKeys = Object.keys(properties);\n    const keys = new Set(valueKeys.concat(propertiesKeys));\n\n    keys.forEach(key => {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults && defaults[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v };\n        errors.push(e);\n        return;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        e.path = [key].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options);\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'partial';\n  const type = `{${ks.join()},...}`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults && defaults[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        e.path = [key].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const { types } = options;\n  const fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (\"development\" !== 'production') {\n      throw new Error(`No struct validator function found for type \"${schema}\".`);\n    } else {\n      throw new Error(`Invalid type: ${schema}`);\n    }\n  }\n\n  const kind = func(fn, defaults, options);\n  const name = 'scalar';\n  const type = schema;\n  const validate = value => {\n    const [error, result] = kind.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const array = scalar('array', undefined, options);\n  const name = 'tuple';\n  const type = `[${kinds.map(k => k.type).join()}]`;\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = [];\n    const errors = [];\n    const length = Math.max(value.length, kinds.length);\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i];\n      const v = value[i];\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v };\n        errors.push(e);\n        continue;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        e.path = [i].concat(e.path);\n        e.data = value;\n        errors.push(e);\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const name = 'union';\n  const type = kinds.map(k => k.type).join(' | ');\n  const validate = (value = resolveDefaults(defaults)) => {\n    let error;\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value);\n      if (!e) return [undefined, r];\n      error = e;\n    }\n\n    error.type = type;\n    return [error];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (\"development\" !== 'production') {\n      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options));\n  const name = 'intersection';\n  const type = types.map(t => t.type).join(' & ');\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value;\n\n    for (const t of types) {\n      const [e, r] = t.validate(v);\n\n      if (e) {\n        e.type = type;\n        return [e];\n      }\n\n      v = r;\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = ['arguments', 'array', 'boolean', 'buffer', 'date', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined\n};\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type;\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = _extends({}, Types, config.types || {});\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults$$1, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (\"development\" !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true });\n    Object.defineProperty(Struct, KIND, { value: kind });\n\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value);\n      if (error) throw new StructError(error);\n      return result;\n    };\n\n    Struct.test = value => {\n      const [error] = kind.validate(value);\n      return !error;\n    };\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value);\n      if (error) return [new StructError(error)];\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name];\n\n    struct[name] = (schema, defaults$$1, options) => {\n      const type = kind(schema, defaults$$1, _extends({}, options, { types }));\n      const s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct();\n\nexports.struct = struct;\nexports.superstruct = superstruct;\nexports.isStruct = isStruct;\nexports.StructError = StructError;\n//# sourceMappingURL=index.js.map"},"hash":"cc078cfe9a29f8df7ad48f2858a34e48"}